import { ConstructorFragment, Fragment, FunctionFragment } from '@ethersproject/abi';
import { BigNumber, BigNumberish, BytesLike, ContractReceipt as EthersContractReceipt, ContractTransaction as EthersContractTransaction, PopulatedTransaction, providers } from 'ethers';
import { Contract } from './contract';
import { AddressLike } from './types';
export interface ContractReceipt<TFunction extends SendFunction<any, any> | ConstructorFunction<any> = SendFunction> extends EthersContractReceipt {
    function: TFunction;
}
export interface ContractTransaction<TFunction extends SendFunction<any, any> | ConstructorFunction<any> = SendFunction> extends EthersContractTransaction {
    function: TFunction;
}
export interface FunctionOptions<TArgs extends any[] = []> {
    args?: TArgs;
    value?: BigNumberish;
    nonce?: BigNumberish;
    gas?: BigNumberish;
    price?: BigNumberish;
    block?: providers.BlockTag;
    from?: AddressLike;
    bytecode?: BytesLike;
}
export declare function isFunctionOptions<TArgs extends any[] = []>(value: any): value is FunctionOptions<TArgs>;
export declare function resolveFunctionOptions<TArgs extends any[] = []>(...args: [FunctionOptions<TArgs>] | TArgs): FunctionOptions<TArgs>;
export declare class ContractFunction<TArgs extends any[] = [], TFragment extends Fragment = Fragment, TContract extends Contract = Contract> {
    readonly contract: TContract;
    readonly fragment: TFragment;
    readonly options: FunctionOptions<TArgs>;
    readonly __TYPE__?: string;
    static isContractFunction(fn: any): fn is ContractFunction<any, any, any>;
    static create<TArgs extends any[] = [], TFragment extends Fragment = Fragment, TContract extends Contract = Contract>(contract: TContract, fragment: TFragment, ...args: TArgs): ContractFunction<TArgs, TFragment, TContract>;
    static create<TArgs extends any[] = [], TFragment extends Fragment = Fragment, TContract extends Contract = Contract>(contract: TContract, fragment: TFragment, options: FunctionOptions<TArgs>): ContractFunction<TArgs, TFragment, TContract>;
    constructor(contract: TContract, fragment: TFragment, options?: FunctionOptions<TArgs>);
    get ref(): this;
    args(...args: TArgs): this;
    value(value?: BigNumberish): this;
    bytecode(bytecode?: BytesLike): this;
    nonce(nonce?: number): this;
    block(block?: providers.BlockTag): this;
    gas(limit?: BigNumberish, price?: BigNumberish): this;
    from(from?: AddressLike): this;
    refine(options?: FunctionOptions<TArgs>): this;
}
export declare class CallFunction<TArgs extends any[] = [], TReturn extends any = unknown, TContract extends Contract = Contract> extends ContractFunction<TArgs, FunctionFragment, TContract> {
    readonly __TYPE__?: string;
    static isCallFunction(fn: any): fn is CallFunction<any, any, any>;
    protected populated?: Promise<PopulatedTransaction>;
    call(): Promise<TReturn>;
    attach(contract: TContract): this;
    populate(refresh?: boolean): Promise<PopulatedTransaction>;
}
export declare class SendFunction<TArgs extends any[] = [], TReturn extends any = void, TContract extends Contract = Contract> extends CallFunction<TArgs, TReturn, TContract> {
    readonly __TYPE__?: string;
    static isSendFunction(fn: any): fn is SendFunction<any, any, any>;
    estimate(): Promise<BigNumber>;
    send(wait?: true): Promise<ContractReceipt<SendFunction<TArgs, TReturn, TContract>>>;
    send(wait?: false): Promise<ContractTransaction<SendFunction<TArgs, TReturn, TContract>>>;
}
export declare class ConstructorFunction<TArgs extends any[] = [], TContract extends Contract = Contract> extends ContractFunction<TArgs, ConstructorFragment, TContract> {
    readonly __TYPE__?: string;
    static isConstructorFunction(fn: any): fn is ConstructorFunction<any, any>;
    protected populated?: Promise<PopulatedTransaction>;
    call(): Promise<string>;
    estimate(): Promise<BigNumber>;
    send(wait?: true): Promise<ContractReceipt<ConstructorFunction<TArgs, TContract>>>;
    send(wait?: false): Promise<ContractTransaction<ConstructorFunction<TArgs, TContract>>>;
    populate(refresh?: boolean): Promise<PopulatedTransaction>;
}
