import { ContractReceipt as EthersContractReceipt } from 'ethers';
import { Contract } from './contract';
import { CallFunction, ContractReceipt, SendFunction } from './function';
import { ProxiedFunction } from './types';
export declare function mock<TContract extends Contract = Contract>(contract: TContract): Promise<MockContract<TContract>>;
export declare type MockContract<TContract extends Contract = Contract> = {
    [TKey in keyof TContract]: TContract[TKey] extends ProxiedFunction<any> ? TContract[TKey] & RefinableStub<Parameters<TContract[TKey]['args']>> : TContract[TKey];
} & {
    forward<TArgs extends any[] = any, TReturn = any, TContract extends Contract = Contract>(send: SendFunction<TArgs, TReturn, TContract>, ...args: TArgs): Promise<ContractReceipt<SendFunction<TArgs, TReturn, TContract>>>;
    forward<TArgs extends any[] = any, TReturn = any>(call: CallFunction<TArgs, TReturn>, ...args: TArgs): Promise<TReturn>;
};
export declare type Stub<TOutput extends any[] = any[]> = {
    returns(...args: TOutput): Promise<EthersContractReceipt>;
    reverts(reason: string): Promise<EthersContractReceipt>;
    reset(): Promise<EthersContractReceipt>;
};
export declare type RefinableStub<TInput extends any[] = any[], TOutput extends any[] = any[]> = Stub<TOutput> & {
    given(...args: TInput): Stub<TOutput>;
    reset(): Promise<EthersContractReceipt>;
};
