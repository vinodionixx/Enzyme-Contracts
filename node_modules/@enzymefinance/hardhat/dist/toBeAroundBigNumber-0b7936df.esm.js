import { BigNumber } from 'ethers';
import { matcherHint } from 'jest-matcher-utils';

function forceFail(error, invert) {
  var pass = invert ? true : false;
  var message = typeof error === 'function' ? error : function () {
    return error;
  };
  return {
    message: message,
    pass: pass
  };
}
function forcePass(invert) {
  var pass = invert ? false : true;
  return {
    message: function message() {
      return '';
    },
    pass: pass
  };
}
function isTransactionReceipt(value) {
  try {
    expect(value).toMatchObject({
      blockHash: expect.any(String),
      blockNumber: expect.any(Number),
      confirmations: expect.any(Number),
      cumulativeGasUsed: expect.any(Object),
      from: expect.any(String),
      gasUsed: expect.any(Object),
      logsBloom: expect.any(String),
      to: expect.any(String),
      transactionHash: expect.any(String),
      transactionIndex: expect.any(Number)
    });
  } catch (_unused) {
    return false;
  }

  return true;
}

function ensureBigNumbers(received, expected, invert, callback) {
  var receivedBn;
  var expectedBn;

  try {
    receivedBn = BigNumber.from(received);
  } catch (_unused) {
    return forceFail('The received value is not numberish', invert);
  }

  try {
    expectedBn = BigNumber.from(expected);
  } catch (_unused2) {
    return forceFail('The expected value is not numberish', invert);
  }

  return callback(receivedBn, expectedBn);
}

var ignoreGasMatchers = false;
function setIgnoreGasMatchers(ignore) {
  ignoreGasMatchers = ignore;
}
var defaultTolerance$1 = 0.1; // 10% tolerance

function setGasCostAssertionTolerance(tolerance) {
  defaultTolerance$1 = tolerance;
} // NOTE: The tolerance only applies to cost decrease, not increase. The reason for
// that is that in case of big cost improvements (reductions) you should get notified
// so that you can further restrict the gas cost assertion so that future degradations
// can be caught.

function toCostLessThan(received, expected, tolerance) {
  var _this = this;

  if (!isTransactionReceipt(received)) {
    throw new Error('The received value is not a transaction receipt');
  }

  var toleranceBn = BigNumber.from((tolerance !== null && tolerance !== void 0 ? tolerance : defaultTolerance$1) * 100);

  if (!(toleranceBn.lt(100) && toleranceBn.gte(0))) {
    throw new Error('Tolerance must be between 0% and 100%');
  }

  if (ignoreGasMatchers) {
    return forcePass(this.isNot);
  }

  return ensureBigNumbers(received.gasUsed, expected, this.isNot, function (received, expected) {
    var pass = received.lt(expected) && received.gt(expected.sub(expected.mul(toleranceBn).div(100)));
    var message = pass ? function () {
      return matcherHint('.toCostLessThan', "".concat(received), "".concat(expected, " [").concat(toleranceBn, "% tolerance]"), _this);
    } : function () {
      return matcherHint('.toCostLessThan', "".concat(received), "".concat(expected, " [").concat(toleranceBn, "% tolerance]"), _this);
    };
    return {
      message: message,
      pass: pass
    };
  });
}

var defaultTolerance = 0.1; // 10% tolerance

function setBeAroundBigNumberAssertionTolerance(tolerance) {
  defaultTolerance = tolerance;
}
function toBeAroundBigNumber(received, expected, tolerance) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var toleranceBn = BigNumber.from((tolerance !== null && tolerance !== void 0 ? tolerance : defaultTolerance) * 100);

    if (!(toleranceBn.lt(100) && toleranceBn.gt(0))) {
      throw new Error('Tolerance must be between 0% and 100%');
    }

    var min = expected.mul(BigNumber.from(100).sub(toleranceBn)).div(BigNumber.from(100));
    var max = expected.mul(BigNumber.from(100).add(toleranceBn)).div(BigNumber.from(100));
    var pass = received.gte(min) && received.lte(max);

    var message = function message() {
      return matcherHint('.toBeAroundBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

export { setIgnoreGasMatchers as a, setBeAroundBigNumberAssertionTolerance as b, toCostLessThan as c, ensureBigNumbers as e, forceFail as f, isTransactionReceipt as i, setGasCostAssertionTolerance as s, toBeAroundBigNumber as t };
