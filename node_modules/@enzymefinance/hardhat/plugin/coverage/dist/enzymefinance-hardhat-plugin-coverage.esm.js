import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { instrumentSources } from '@enzymefinance/coverage';
import deepmerge from 'deepmerge';
import fs from 'fs-extra';
import glob from 'glob';
import { extendConfig, task } from 'hardhat/config';
import path from 'path';
import { v as validateDir, r as regexOrString } from '../../../dist/utils-04d50688.esm.js';
import '@babel/runtime/helpers/slicedToArray';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
extendConfig(function (config, userConfig) {
  var _userConfig$codeCover;

  var defaults = {
    clear: true,
    exclude: [],
    include: [],
    path: path.resolve(config.paths.cache, './coverage')
  };
  var provided = (_userConfig$codeCover = userConfig.codeCoverage) !== null && _userConfig$codeCover !== void 0 ? _userConfig$codeCover : {};
  config.codeCoverage = deepmerge(defaults, provided);
  config.codeCoverage.path = validateDir(config.paths.root, config.codeCoverage.path);
  config.codeCoverage.include = config.codeCoverage.include.map(function (item) {
    return regexOrString(item);
  });
  config.codeCoverage.exclude = config.codeCoverage.exclude.map(function (item) {
    return regexOrString(item);
  });
});
var description = 'Add code coverage instrumentations statements during compilation';
task('coverage', description, /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(args, env) {
    var config, dir, files, sources, instrumentation, cache, originalSources, originalCompilers, clonedCompilers;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            config = env.config.codeCoverage;
            dir = path.resolve(config.path, 'contracts');
            files = glob.sync('**/*.sol', {
              cwd: env.config.paths.sources
            }); // First, grab alles files and their source and target locations.

            _context2.next = 5;
            return Promise.all(files.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {
                var name, origin, destination, source, included, excluded, instrument;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        name = path.basename(file, '.sol');
                        origin = path.resolve(env.config.paths.sources, file);
                        destination = path.resolve(dir, file);
                        _context.next = 5;
                        return fs.readFile(origin, 'utf8');

                      case 5:
                        source = _context.sent;
                        included = config.include.length ? config.include.some(function (rule) {
                          return name.match(rule) || file.match(rule);
                        }) : true;
                        excluded = config.exclude.length ? config.exclude.some(function (rule) {
                          return name.match(rule) || file.match(rule);
                        }) : false;
                        instrument = included && !excluded;
                        return _context.abrupt("return", {
                          destination: destination,
                          instrument: instrument,
                          origin: origin,
                          source: source
                        });

                      case 10:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x3) {
                return _ref2.apply(this, arguments);
              };
            }()));

          case 5:
            sources = _context2.sent;
            // Then create the instrumentation metadata for all matched files.
            instrumentation = instrumentSources(sources.reduce(function (carry, current) {
              if (!current.instrument) {
                return carry;
              }

              return _objectSpread(_objectSpread({}, carry), {}, _defineProperty({}, current.origin, current.source));
            }, {})); // Prepare the temporary instrumentation source & metadata directory.

            _context2.t0 = config.clear;

            if (!_context2.t0) {
              _context2.next = 12;
              break;
            }

            _context2.next = 11;
            return fs.pathExists(config.path);

          case 11:
            _context2.t0 = _context2.sent;

          case 12:
            if (!_context2.t0) {
              _context2.next = 15;
              break;
            }

            _context2.next = 15;
            return fs.remove(config.path);

          case 15:
            _context2.next = 17;
            return Promise.all(sources.map(function (file) {
              var _instrumentation$inst, _instrumentation$inst2;

              var output = (_instrumentation$inst = (_instrumentation$inst2 = instrumentation.instrumented[file.origin]) === null || _instrumentation$inst2 === void 0 ? void 0 : _instrumentation$inst2.instrumented) !== null && _instrumentation$inst !== void 0 ? _instrumentation$inst : file.source;
              return fs.outputFile(file.destination, output, 'utf8');
            }));

          case 17:
            _context2.next = 19;
            return fs.outputJson(path.resolve(config.path, 'metadata.json'), instrumentation.metadata, {
              spaces: 2
            });

          case 19:
            // Move the original compilation cache file out of harms way.
            cache = path.join(env.config.paths.cache, 'solidity-files-cache.json');
            _context2.next = 22;
            return fs.pathExists(cache);

          case 22:
            if (!_context2.sent) {
              _context2.next = 25;
              break;
            }

            _context2.next = 25;
            return fs.move(cache, "".concat(cache, ".bkp"), {
              overwrite: true
            });

          case 25:
            // Override the contract source path & compiler config for the `compile` task.
            originalSources = env.config.paths.sources;
            originalCompilers = env.config.solidity.compilers;
            clonedCompilers = JSON.parse(JSON.stringify(originalCompilers));
            env.config.paths.sources = dir;
            env.config.solidity.compilers = clonedCompilers.map(function (item) {
              var _item$settings, _item$settings$optimi;

              if (!!((_item$settings = item.settings) !== null && _item$settings !== void 0 && (_item$settings$optimi = _item$settings.optimizer) !== null && _item$settings$optimi !== void 0 && _item$settings$optimi.enabled)) {
                item.settings.optimizer.enabled = false;
              }

              return item;
            });
            _context2.next = 32;
            return env.run('compile', args);

          case 32:
            env.config.paths.sources = originalSources; // Restore the original compilation cache file.

            _context2.next = 35;
            return fs.pathExists("".concat(cache, ".bkp"));

          case 35:
            if (!_context2.sent) {
              _context2.next = 38;
              break;
            }

            _context2.next = 38;
            return fs.move("".concat(cache, ".bkp"), cache, {
              overwrite: true
            });

          case 38:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}()).addFlag('force', 'Force compilation ignoring cache');
