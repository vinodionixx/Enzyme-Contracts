import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { mergeCoverageReports } from '@enzymefinance/coverage';
import fs from 'fs-extra';
import glob from 'glob';
import Reporter from 'istanbul-lib-report';
import Reports from 'istanbul-reports';
import path from 'path';

var globalTeardown = /*#__PURE__*/(function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {
    var tmp, files, outputs, unique, metadata, hits, coverage, context;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (process.env.__HARDHAT_COVERAGE_TEMPDIR__) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return");

          case 2:
            tmp = process.env.__HARDHAT_COVERAGE_TEMPDIR__;
            _context.next = 5;
            return fs.pathExists(tmp);

          case 5:
            if (_context.sent) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return");

          case 7:
            files = glob.sync(path.join(tmp, '*.json'));
            _context.next = 10;
            return Promise.all(files.map(function (file) {
              return fs.readJson(file);
            }));

          case 10:
            outputs = _context.sent;

            if (outputs.length) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return");

          case 13:
            unique = outputs.map(function (item) {
              return item.metadata;
            }).filter(function (item, index, array) {
              return array.indexOf(item) === index;
            });

            if (!(unique.length !== 1)) {
              _context.next = 16;
              break;
            }

            throw new Error('Mismatching code coverage metadata');

          case 16:
            _context.next = 18;
            return fs.readJson(unique[0]);

          case 18:
            metadata = _context.sent;
            hits = outputs.reduce(function (carry, current) {
              Object.entries(current.hits).forEach(function (_ref2) {
                var _carry$hash;

                var _ref3 = _slicedToArray(_ref2, 2),
                    hash = _ref3[0],
                    hits = _ref3[1];

                carry[hash] = ((_carry$hash = carry[hash]) !== null && _carry$hash !== void 0 ? _carry$hash : 0) + hits;
              });
              return carry;
            }, {});
            coverage = mergeCoverageReports(hits, metadata);
            context = Reporter.createContext({
              coverageMap: coverage,
              dir: config.coverageDirectory,
              watermarks: {
                branches: [50, 80],
                functions: [50, 80],
                lines: [50, 80],
                statements: [50, 80]
              }
            });
            config.coverageReporters.forEach(function (reporter) {
              var report = Reports.create(reporter);
              report.execute(context);
            });
            _context.next = 25;
            return fs.emptyDir(tmp);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
})();

export default globalTeardown;
