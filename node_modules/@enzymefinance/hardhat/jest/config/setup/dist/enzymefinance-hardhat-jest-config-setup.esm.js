import { utils, BigNumber } from 'ethers';
import { matcherHint, printExpected, printReceived } from 'jest-matcher-utils';
import { e as ensureBigNumbers, i as isTransactionReceipt, f as forceFail, t as toBeAroundBigNumber, c as toCostLessThan } from '../../../../dist/toBeAroundBigNumber-0b7936df.esm.js';
import { Contract, resolveAddress, SendFunction, CallFunction, resolveArguments, extractEvent, ContractFunction } from '@enzymefinance/ethers';
import { diff } from 'jest-diff';
import _typeof from '@babel/runtime/helpers/esm/typeof';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';

function toBeGtBigNumber(received, expected) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var pass = received.gt(expected);

    var message = function message() {
      return matcherHint('.toBeGtBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

function toBeGteBigNumber(received, expected) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var pass = received.gte(expected);

    var message = function message() {
      return matcherHint('.toBeGteBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

function toBeLtBigNumber(received, expected) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var pass = received.lt(expected);

    var message = function message() {
      return matcherHint('.toBeLtBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

function toBeLteBigNumber(received, expected) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var pass = received.lte(expected);

    var message = function message() {
      return matcherHint('.toBeLteBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

function toEqBigNumber(received, expected) {
  var _this = this;

  return ensureBigNumbers(received, expected, this.isNot, function (received, expected) {
    var pass = received.eq(expected);

    var message = function message() {
      return matcherHint('.toEqBigNumber', "".concat(received), "".concat(expected), _this);
    };

    return {
      message: message,
      pass: pass
    };
  });
}

function toBeReverted(received) {
  var _this = this;

  var error = received === null || received === void 0 ? void 0 : received.message;
  var isReverted = (error === null || error === void 0 ? void 0 : error.search('revert')) >= 0;
  var isThrown = (error === null || error === void 0 ? void 0 : error.search('invalid opcode')) >= 0;
  var isError = (error === null || error === void 0 ? void 0 : error.search('code=')) >= 0;
  var pass = isReverted || isThrown || isError;
  var message = pass ? function () {
    return matcherHint('.toBeReverted', undefined, error, _this);
  } : function () {
    return matcherHint('.toBeReverted', undefined, error, _this);
  };
  return {
    message: message,
    pass: pass
  };
}

function toBeRevertedWith(received, match) {
  var _this = this;

  var error = received === null || received === void 0 ? void 0 : received.message;
  var isReverted = (error === null || error === void 0 ? void 0 : error.search('revert')) >= 0;
  var isThrown = (error === null || error === void 0 ? void 0 : error.search('invalid opcode')) >= 0;
  var isError = (error === null || error === void 0 ? void 0 : error.search('code=')) >= 0;
  var isMatch = (error === null || error === void 0 ? void 0 : error.match(match)) != null;
  var pass = (isReverted || isThrown || isError) && isMatch;
  var message = pass ? function () {
    return matcherHint('.toBeRevertedWith', error, "".concat(match), _this);
  } : function () {
    return matcherHint('.toBeRevertedWith', error, "".concat(match), _this);
  };
  return {
    message: message,
    pass: pass
  };
}

function toBeReceipt(received) {
  var _this = this;

  var pass = isTransactionReceipt(received);
  var message = pass ? function () {
    return matcherHint('.toBeReceipt', undefined, undefined, _this);
  } : function () {
    return matcherHint('.toBeReceipt', undefined, undefined, _this);
  };
  return {
    message: message,
    pass: pass
  };
}

function resolveFunctionFragment(subject, fragment) {
  var resolved = resolveFragment(subject, fragment);

  if (!utils.FunctionFragment.isFunctionFragment(resolved)) {
    throw new Error("Failed to resolve function fragment. Received event fragment ".concat(resolved.format('full')));
  }

  return resolved;
}
function resolveEventFragment(subject, fragment) {
  var resolved = resolveFragment(subject, fragment);

  if (!utils.EventFragment.isEventFragment(resolved)) {
    throw new Error("Failed to resolve event fragment. Received function fragment ".concat(resolved.format('full')));
  }

  return resolved;
}
function resolveFragment(subject, fragment) {
  if (utils.EventFragment.isEventFragment(subject) || utils.FunctionFragment.isFunctionFragment(subject)) {
    return subject;
  }

  if (utils.EventFragment.isEventFragment(fragment) || utils.FunctionFragment.isFunctionFragment(fragment)) {
    return fragment;
  }

  if (fragment == null && typeof subject === 'string' && subject.indexOf('(')) {
    var _fragment = utils.Fragment.fromString(subject);

    if (utils.EventFragment.isEventFragment(_fragment) || utils.FunctionFragment.isFunctionFragment(_fragment)) {
      return _fragment;
    }
  }

  if (Contract.isContract(subject)) {
    if (fragment == null) {
      throw new Error('Missing event/function fragment or name');
    }

    if (utils.isHexString(fragment)) {
      for (var name in subject.abi.functions) {
        if (fragment === subject.abi.getSighash(name)) {
          return subject.abi.functions[name];
        }
      }

      for (var _name in subject.abi.events) {
        if (fragment === subject.abi.getSighash(_name)) {
          return subject.abi.functions[_name];
        }
      }
    } else if (fragment.indexOf('(') === -1) {
      var _find;

      var _name2 = fragment.trim();

      var fns = Object.entries(subject.abi.functions);
      var events = Object.entries(subject.abi.events);

      var _ref = (_find = [].concat(_toConsumableArray(fns), _toConsumableArray(events)).find(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
            key = _ref4[0];

        return key.split('(')[0] === _name2;
      })) !== null && _find !== void 0 ? _find : [],
          _ref2 = _slicedToArray(_ref, 2),
          match = _ref2[1];

      if (match != null) {
        return match;
      }
    }
  }

  throw new Error("Failed to resolve function or event fragment ".concat(fragment));
}
var asymmetricMatcher = Symbol["for"]('jest.asymmetricMatcher');
function resolveParamMatchers(params, value) {
  if (typeof value === 'undefined') {
    return expect.anything();
  }

  if ((value === null || value === void 0 ? void 0 : value.$$typeof) === asymmetricMatcher) {
    return value;
  }

  if (Array.isArray(params)) {
    // Verify that there are no unexpected params.
    if (Array.isArray(value)) {
      if (value.length !== params.length) {
        var formatted = params.map(function (param) {
          return param.format('full');
        }).join(', ');
        throw new Error("Array length of expected value doesn't match parameter array length ([".concat(formatted, "])"));
      }
    } else if (_typeof(value) === 'object') {
      var keys = params.map(function (param, index) {
        return "".concat(param.name || index);
      });
      var mismatch = Object.keys(value).find(function (key) {
        return !keys.includes(key);
      });

      if (mismatch != null) {
        var _formatted = params.map(function (param) {
          return param.format('full');
        }).join(', ');

        throw new Error("Invalid key \"".concat(mismatch, "\" for parameter shape (").concat(_formatted, ")"));
      }
    }

    return params.map(function (type, index) {
      var key = "".concat(Array.isArray(value) ? index : type.name);
      var inner = value === null || value === void 0 ? void 0 : value[key]; // All named parameters are required. Unnamed ones are optional.

      if (inner == null && type.name != null) {
        throw new Error("Missing value for param (".concat(type.format('full'), ")"));
      }

      return resolveParamMatchers(type, inner);
    });
  }

  if (params.type === 'address') {
    return resolveAddress(value);
  }

  if (params.type === 'tuple') {
    return resolveParamMatchers(params.components, value);
  }

  if (params.baseType === 'array') {
    if (!Array.isArray(value)) {
      throw new Error('Invalid array value');
    }

    return value.map(function (inner) {
      return resolveParamMatchers(params.arrayChildren, inner);
    });
  }

  if (params.type.match(/^u?int/)) {
    return "".concat(BigNumber.from(value));
  }

  return value;
}

function toMatchFunctionOutput(received, fragment, expected) {
  var _this = this;

  var invert = this.isNot;
  var resolvedFragment;
  var receivedParams;
  var expectedMatchers;

  try {
    if (SendFunction.isSendFunction(fragment) || CallFunction.isCallFunction(fragment)) {
      resolvedFragment = fragment.fragment;
    } else {
      resolvedFragment = resolveFunctionFragment(fragment);
    }
  } catch (e) {
    return forceFail("Failed to resolve function fragment: ".concat(e), invert);
  }

  if (!resolvedFragment.outputs) {
    var formatted = resolvedFragment.format('full');
    return forceFail("The function fragment does not have any output signature: ".concat(formatted), invert);
  }

  var types = resolvedFragment.outputs;

  try {
    var params = types.length === 1 ? types[0] : types;
    receivedParams = resolveArguments(params, received);
  } catch (e) {
    return forceFail("Failed to resolve received arguments: ".concat(e), invert);
  }

  try {
    var _params = types.length === 1 ? types[0] : types;

    expectedMatchers = resolveParamMatchers(_params, expected);
  } catch (e) {
    return forceFail("Failed to resolve expected matchers: ".concat(e), invert);
  }

  var pass = this.equals(receivedParams, expectedMatchers);
  var message = pass ? function () {
    return matcherHint('.toMatchFunctionOutput', undefined, undefined, _this);
  } : function () {
    var suffix = diff(receivedParams, expectedMatchers);
    return matcherHint('.toMatchFunctionOutput', undefined, undefined, _this) + "\n\n".concat(suffix);
  };
  return {
    message: message,
    pass: pass
  };
}

function toHaveEmitted(receipt, event) {
  var _this = this;

  var abi = receipt["function"].contract.abi;
  var fragment = utils.EventFragment.isEventFragment(event) ? event : abi.getEvent(event);
  var matches = extractEvent(receipt, fragment);
  var signature = fragment.format('full');
  var pass = !!(matches !== null && matches !== void 0 && matches.length);
  var message = pass ? function () {
    var _matches$length;

    return matcherHint('.toHaveEmitted', undefined, undefined, _this) + '\n\n' + "Expected event not to have been emitted\n" + "  ".concat(printExpected(signature), "\n") + "Actual:\n" + "  ".concat(printReceived("Event was emitted ".concat((_matches$length = matches === null || matches === void 0 ? void 0 : matches.length) !== null && _matches$length !== void 0 ? _matches$length : 0, " times")));
  } : function () {
    var _matches$length2;

    return matcherHint('.toHaveEmitted', undefined, undefined, _this) + '\n\n' + "Expected event to have been emitted\n" + "  ".concat(printExpected(signature), "\n") + "Actual:\n" + "  ".concat(printReceived("Event was emitted ".concat((_matches$length2 = matches === null || matches === void 0 ? void 0 : matches.length) !== null && _matches$length2 !== void 0 ? _matches$length2 : 0, " times")));
  };
  return {
    message: message,
    pass: pass
  };
}

function toHaveEmittedWith(receipt, event, expected) {
  var _this = this;

  var invert = this.isNot;
  var resolvedFragment;
  var expectedMatchers;

  try {
    resolvedFragment = resolveEventFragment(receipt["function"].contract, event);
  } catch (e) {
    return forceFail("Failed to resolve event fragment: ".concat(e), invert);
  }

  var types = resolvedFragment.inputs;

  try {
    expectedMatchers = resolveParamMatchers(types, expected);
  } catch (e) {
    return forceFail("Failed to resolve expected matchers: ".concat(e), invert);
  }

  var events = extractEvent(receipt, resolvedFragment);
  var args = events.map(function (event) {
    return resolveArguments(types, event.args);
  });
  var matcher = expect.arrayContaining([expectedMatchers]);
  var pass = this.equals(args, matcher);
  var signature = resolvedFragment.format('full');
  var message = pass ? function () {
    return matcherHint('.toHaveEmittedWith', signature, undefined, _this);
  } : function () {
    var suffix = diff(args[args.length - 1], expectedMatchers);
    return matcherHint('.toHaveEmittedWith', signature, undefined, _this) + "\n\n".concat(suffix);
  };
  return {
    message: message,
    pass: pass
  };
}

function toMatchEventArgs(received, expected) {
  var _this = this;

  var invert = this.isNot;
  var receivedParams;
  var expectedMatchers;
  var types = received.eventFragment.inputs;

  try {
    receivedParams = resolveArguments(types, received.args);
  } catch (e) {
    return forceFail("Failed to resolve received arguments: ".concat(e), invert);
  }

  try {
    expectedMatchers = resolveParamMatchers(types, expected);
  } catch (e) {
    return forceFail("Failed to resolve received arguments: ".concat(e), invert);
  }

  var pass = this.equals(receivedParams, expectedMatchers);
  var message = pass ? function () {
    return matcherHint('.toMatchEventArgs', undefined, undefined, _this);
  } : function () {
    var suffix = diff(receivedParams, expectedMatchers);
    return matcherHint('.toMatchEventArgs', undefined, undefined, _this) + "\n\n".concat(suffix);
  };
  return {
    message: message,
    pass: pass
  };
}

function ensureParameters(subject, invert, callback) {
  var _contract$provider;

  var fn = ContractFunction.isContractFunction(subject) ? subject : typeof subject === 'function' && ContractFunction.isContractFunction(subject === null || subject === void 0 ? void 0 : subject.ref) ? subject.ref : undefined;
  var contract = ContractFunction.isContractFunction(fn) ? fn.contract : Contract.isContract(subject) ? subject : undefined;

  if (!contract) {
    var error = 'Missing contract instance for contract call history assertion';
    return forceFail(error, invert);
  }

  var history = contract === null || contract === void 0 ? void 0 : (_contract$provider = contract.provider) === null || _contract$provider === void 0 ? void 0 : _contract$provider.history;

  if (!history) {
    var _error = 'Invalid or unsupported provider for contract call history assertion';
    return forceFail(_error, invert);
  }

  var fragment = ContractFunction.isContractFunction(fn) ? fn.fragment : undefined;
  return callback(history, contract, fragment);
}

function toHaveBeenCalledOnContract(subject) {
  var _this = this;

  var invert = this.isNot;
  return ensureParameters(subject, invert, function (history, contract, fragment) {
    var signature = fragment ? contract.abi.getSighash(fragment) : '0x';
    var method = fragment === null || fragment === void 0 ? void 0 : fragment.format('full');
    var expected = "".concat(method ? method : 'contract');
    var pass = history.calls(contract).some(function (call) {
      return call.startsWith(signature);
    });
    var message = pass ? function () {
      return matcherHint('.toHaveBeenCalledOnContract', expected, undefined, _this) + '\n\n' + "Expected: ".concat(printExpected('not to have been called'), "\n") + "Actual: ".concat(printReceived('has been called'));
    } : function () {
      return matcherHint('.toHaveBeenCalledOnContract', expected, undefined, _this) + '\n\n' + "Expected: ".concat(printExpected('to have been called'), "\n") + "Actual: ".concat(printReceived('has not been called'));
    };
    return {
      message: message,
      pass: pass
    };
  });
}

function toHaveBeenCalledOnContractWith(subject) {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var invert = this.isNot;
  return ensureParameters(subject, invert, function (history, contract, fragment) {
    if (!utils.FunctionFragment.isFunctionFragment(fragment)) {
      var error = 'Missing or invalid function fragment for call history assertion';
      return forceFail(error, invert);
    }

    var resolved = resolveArguments(fragment.inputs, args);
    var signature = contract.abi.encodeFunctionData(fragment, resolved);
    var calls = history.calls(contract);
    var pass = calls.some(function (call) {
      return call.startsWith(signature);
    });
    var expectedFunction = fragment.format('full');
    var expectedArgs = fragment.inputs.map(function (_, index) {
      return "".concat(resolved[index]);
    });
    var message = pass ? function () {
      return matcherHint('.toHaveBeenCalledOnContractWith', "".concat(expectedFunction), "\n  ".concat(expectedArgs.join(',\n  '), "\n"), _this) + '\n\n' + "Expected: ".concat(printExpected('to not have been called'), "\n") + "Actual: ".concat(printReceived('has been called'));
    } : function () {
      return matcherHint('.toHaveBeenCalledOnContractWith', "".concat(expectedFunction), "\n  ".concat(expectedArgs.join(',\n  '), "\n"), _this) + '\n\n' + "Expected: ".concat(printExpected('to have been called'), "\n") + "Actual: ".concat(printReceived('has not been called with these arguments')).concat(printHelper(contract, fragment, calls));
    };
    return {
      message: message,
      pass: pass
    };
  });
}

function printHelper(contract, fragment, calls) {
  var signature = contract.abi.getSighash(fragment);
  var latest = calls.reverse().find(function (call) {
    return call.startsWith(signature);
  });

  if (latest == null) {
    return '';
  }

  var args = contract.abi.decodeFunctionData(fragment, latest);
  var printed = fragment.inputs.map(function (_, index) {
    return "".concat(args[index]);
  });
  return "\n\nLast called with:\n\n".concat(fragment.name, "(\n  ").concat(printed.join(',\n  '), " \n)");
}

function toBeProperAddress(received) {
  var _this = this;

  var pass = new RegExp('^0x[0-9-a-fA-F]{40}$').test(received);

  var message = function message() {
    return matcherHint('.toBeProperAddress', received, undefined, _this);
  };

  return {
    message: message,
    pass: pass
  };
}

function toBeProperHex(received, length) {
  var _this = this;

  var repeat = length == null ? '*' : "{".concat(length, "}");
  var pass = new RegExp("^0x[0-9-a-fA-F]".concat(repeat, "$")).test(received);

  var message = function message() {
    return matcherHint('.toBeProperHex', received, length == null ? undefined : "of length ".concat(length), _this);
  };

  return {
    message: message,
    pass: pass
  };
}

function toBeProperPrivateKey(received) {
  var _this = this;

  var pass = new RegExp('^0x[0-9-a-fA-F]{64}$').test(received);

  var message = function message() {
    return matcherHint('.toBeProperPrivateKey', received, undefined, _this);
  };

  return {
    message: message,
    pass: pass
  };
}

function toMatchAddress(received, expected) {
  var _this = this;

  var invert = this.isNot;
  var receivedAddress;
  var expectedAddress;

  try {
    receivedAddress = resolveAddress(received);
  } catch (e) {
    return forceFail("The received value is not an address: ".concat(e), invert);
  }

  try {
    expectedAddress = resolveAddress(expected);
  } catch (e) {
    return forceFail("The expected value is not an address: ".concat(e), invert);
  }

  var pass = receivedAddress === expectedAddress;

  var message = function message() {
    return matcherHint('.toMatchAddress', receivedAddress, expectedAddress, _this);
  };

  return {
    message: message,
    pass: pass
  };
}

function toMatchParams(received, types, expected) {
  var _this = this;

  var invert = this.isNot;
  var receivedParams;
  var expectedMatchers;
  var printed = Array.isArray(types) ? types.map(function (type) {
    return type.format('full');
  }).join(', ') : types.format('full');

  try {
    receivedParams = resolveArguments(types, received);
  } catch (e) {
    return forceFail("Failed to resolve received arguments: ".concat(e), invert);
  }

  try {
    expectedMatchers = resolveParamMatchers(types, expected);
  } catch (e) {
    return forceFail("Failed to resolve received arguments: ".concat(e), invert);
  }

  var pass = this.equals(receivedParams, expectedMatchers);
  var message = pass ? function () {
    return matcherHint('.toMatchParams', printed, undefined, _this);
  } : function () {
    return matcherHint('.toMatchParams', printed, undefined, _this) + "\n\n".concat(diff(receivedParams, expectedMatchers));
  };
  return {
    message: message,
    pass: pass
  };
}

var matchers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toBeGtBigNumber: toBeGtBigNumber,
  toBeGteBigNumber: toBeGteBigNumber,
  toBeLtBigNumber: toBeLtBigNumber,
  toBeLteBigNumber: toBeLteBigNumber,
  toBeAroundBigNumber: toBeAroundBigNumber,
  toEqBigNumber: toEqBigNumber,
  toBeReverted: toBeReverted,
  toBeRevertedWith: toBeRevertedWith,
  toBeReceipt: toBeReceipt,
  toCostLessThan: toCostLessThan,
  toMatchFunctionOutput: toMatchFunctionOutput,
  toHaveEmitted: toHaveEmitted,
  toHaveEmittedWith: toHaveEmittedWith,
  toMatchEventArgs: toMatchEventArgs,
  toHaveBeenCalledOnContract: toHaveBeenCalledOnContract,
  toHaveBeenCalledOnContractWith: toHaveBeenCalledOnContractWith,
  toBeProperAddress: toBeProperAddress,
  toBeProperHex: toBeProperHex,
  toBeProperPrivateKey: toBeProperPrivateKey,
  toMatchAddress: toMatchAddress,
  toMatchParams: toMatchParams
});

expect.extend(matchers); // Allow bignumber values to be serialized properly when used in snapshots.

expect.addSnapshotSerializer({
  serialize: function serialize(value) {
    return BigNumber.from(value).toString();
  },
  test: function test(value) {
    return BigNumber.isBigNumber(value);
  }
}); // Ensure that the global hardhat runtime is used.

jest.mock('hardhat', function () {
  return global.hre;
});
