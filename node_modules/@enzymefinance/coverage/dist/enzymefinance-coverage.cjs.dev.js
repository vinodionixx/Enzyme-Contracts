'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var ethers = require('ethers');
var uuid = require('uuid');
var SolidityParser = require('@solidity-parser/parser');
var istanbulLibCoverage = require('istanbul-lib-coverage');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var SolidityParser__default = /*#__PURE__*/_interopDefault(SolidityParser);

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var BlockDelimiter;

(function (BlockDelimiter) {
  BlockDelimiter["OPEN"] = "{";
  BlockDelimiter["CLOSE"] = "}";
})(BlockDelimiter || (BlockDelimiter = {}));

function inject(parsed, path) {
  var state = _objectSpread$2(_objectSpread$2({}, parsed), {}, {
    instrumentations: {},
    instrumented: parsed.source,
    target: path
  });

  var points = Object.keys(state.injections).sort(function (a, b) {
    return b - a;
  });
  points.forEach(function (point) {
    state.injections[point].forEach(function (injection) {
      switch (injection.type) {
        case 'Statement':
          return injectStatement(state, point, injection);

        case 'Function':
          return injectFunction(state, point, injection);

        case 'Branch':
          return injectBranch(state, point, injection);

        case 'HashMethod':
          return injectHashMethod(state, point, injection);

        case 'BlockDelimiter':
          return injectBlockDelimiter(state, point, injection);
      }
    });
  });
  return state;
}

function split(state, point) {
  return {
    end: state.instrumented.slice(point),
    start: state.instrumented.slice(0, point)
  };
}

function getHash(id) {
  return ethers.utils.id("".concat(id, ":").concat(uuid.v4()));
}

function getMethodIdentifier(id) {
  return "c_".concat(ethers.utils.id(id).slice(0, 10));
}

function getHashMethodDefinition(id) {
  var hash = ethers.utils.id(id).slice(0, 10);
  var method = getMethodIdentifier(id);
  return "function ".concat(method, "(bytes32 c__").concat(hash, ") private pure {} /* hash method */");
}

function getInjectable(id, hash, type) {
  return "".concat(getMethodIdentifier(id), "(").concat(hash, ");/* ").concat(type, " */");
}

function getInjectionComponents(state, point, id, type) {
  var _split = split(state, point),
      start = _split.start,
      end = _split.end;

  var hash = getHash(id);
  var injectable = getInjectable(id, hash, type);
  return {
    end: end,
    hash: hash,
    injectable: injectable,
    start: start
  };
}

function injectStatement(state, point, injection) {
  var type = "statement(".concat(injection.id, ")");
  var id = "".concat(state.target, ":").concat(injection.contract);

  var _getInjectionComponen = getInjectionComponents(state, point, id, type),
      start = _getInjectionComponen.start,
      end = _getInjectionComponen.end,
      hash = _getInjectionComponen.hash,
      injectable = _getInjectionComponen.injectable;

  state.instrumentations[hash] = {
    id: injection.id,
    target: state.target,
    type: 'statement'
  };
  state.instrumented = "".concat(start).concat(injectable).concat(end);
}

function injectFunction(state, point, injection) {
  var label = "function(".concat(injection.id, ")");
  var id = "".concat(state.target, ":").concat(injection.contract);

  var _getInjectionComponen2 = getInjectionComponents(state, point, id, label),
      start = _getInjectionComponen2.start,
      end = _getInjectionComponen2.end,
      hash = _getInjectionComponen2.hash,
      injectable = _getInjectionComponen2.injectable;

  state.instrumentations[hash] = {
    id: injection.id,
    target: state.target,
    type: 'function'
  };
  state.instrumented = "".concat(start).concat(injectable).concat(end);
}

function injectBranch(state, point, injection) {
  var label = "branch(".concat(injection.id, ":").concat(injection.branch, ")");
  var id = "".concat(state.target, ":").concat(injection.contract);

  var _getInjectionComponen3 = getInjectionComponents(state, point, id, label),
      start = _getInjectionComponen3.start,
      end = _getInjectionComponen3.end,
      hash = _getInjectionComponen3.hash,
      injectable = _getInjectionComponen3.injectable;

  state.instrumentations[hash] = {
    branch: injection.branch,
    id: injection.id,
    target: state.target,
    type: 'branch'
  };
  state.instrumented = "".concat(start).concat(injectable).concat(end);
}

function injectHashMethod(state, point, injection) {
  var _split2 = split(state, point),
      start = _split2.start,
      end = _split2.end;

  var id = "".concat(state.target, ":").concat(injection.contract);
  state.instrumented = "".concat(start).concat(getHashMethodDefinition(id)).concat(end);
}

function injectBlockDelimiter(state, point, injection) {
  var _split3 = split(state, point),
      start = _split3.start,
      end = _split3.end;

  state.instrumented = "".concat(start).concat(injection.delimiter).concat(end);
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-disable @typescript-eslint/no-non-null-assertion */

/**
 * Adds injection point to injection points map
 */
function createInjection(state, key, value) {
  var injection = _objectSpread$1(_objectSpread$1({}, value), {}, {
    contract: state.contract
  });

  if (state.injections[key]) {
    state.injections[key].push(injection);
  } else {
    state.injections[key] = [injection];
  }
}
/**
 * Registers injections for statement measurements
 */

function registerStatement(state, expression) {
  var startContract = state.source.slice(0, expression.range[0]);
  var startline = (startContract.match(/\n/g) || []).length + 1;
  var startcol = expression.range[0] - startContract.lastIndexOf('\n') - 1;
  var expressionContent = state.source.slice(expression.range[0], expression.range[1] + 1);
  var endline = startline + (expressionContent.match(/\n/g) || []).length;
  var endcol;

  if (expressionContent.lastIndexOf('\n') >= 0) {
    endcol = state.source.slice(expressionContent.lastIndexOf('\n'), expression.range[1]).length;
  } else {
    endcol = startcol + expressionContent.length + 1;
  }

  var id = state.statements.push({
    end: {
      column: endcol,
      line: endline
    },
    start: {
      column: startcol,
      line: startline
    }
  }) - 1;
  createInjection(state, expression.range[0], {
    id: id,
    type: 'Statement'
  });
}
/**
 * Registers injections for function measurements
 */

function registerFunction(state, expression) {
  var _expression$name;

  var name = expression.type === 'FunctionDefinition' && expression.isConstructor ? 'constructor' : (_expression$name = expression.name) !== null && _expression$name !== void 0 ? _expression$name : ''; // TODO: The `Location` type is wrongly typed in solidty-parser.

  var id = state.functions.push({
    decl: {
      end: expression.body.loc.start,
      start: expression.loc.start
    },
    line: expression.loc.start.line,
    loc: expression.loc,
    name: name
  }) - 1;
  createInjection(state, expression.body.range[0] + 1, {
    id: id,
    type: 'Function'
  });
}
function registerBranch(state, expression) {
  var startContract = state.source.slice(0, expression.range[0]);
  var startline = (startContract.match(/\n/g) || []).length + 1;
  var startcol = expression.range[0] - startContract.lastIndexOf('\n') - 1;
  var loc = {
    end: {
      column: startcol,
      line: startline
    },
    start: {
      column: startcol,
      line: startline
    }
  };
  var id = state.branches.push({
    line: startline,
    loc: loc,
    locations: [],
    type: 'if'
  }) - 1;
  return id;
}
function registerBranchLocation(state, expression) {
  var branch = state.branches[state.branch].locations.length;
  var point = expression.range[0] + (expression.type === 'Block' ? 1 : 0);
  createInjection(state, point, {
    branch: branch,
    id: state.branch,
    type: 'Branch'
  }); // TODO: The `Location` type is wrongly typed in solidty-parser.

  state.branches[state.branch].locations.push(expression.loc);
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function parse(source) {
  var ast = SolidityParser__default['default'].parse(source, {
    loc: true,
    range: true
  });
  var state = {
    branch: undefined,
    branches: [],
    contract: '',
    functions: [],
    injections: {},
    source: source,
    statements: []
  };
  parseExpression(state, ast);
  return {
    branches: state.branches,
    functions: state.functions,
    injections: state.injections,
    source: source,
    statements: state.statements
  };
}

function parseExpression(state, expression) {
  switch (expression.type) {
    case 'Block':
      parseBlock(state, expression);
      break;

    case 'BinaryOperation':
      parseBinaryOperation(state, expression);
      break;

    case 'ContractDefinition':
      parseContractDefinition(state, expression);
      break;

    case 'EmitStatement':
      parseEmitStatement(state, expression);
      break;

    case 'ExpressionStatement':
      parseExpressionStatement(state, expression);
      break;

    case 'ForStatement':
      parseForStatement(state, expression);
      break;

    case 'FunctionCall':
      parseFunctionCall(state, expression);
      break;

    case 'FunctionDefinition':
      parseFunctionDefinition(state, expression);
      break;

    case 'IfStatement':
      parseIfStatement(state, expression);
      break;

    case 'ModifierDefinition':
      parseModifierDefinition(state, expression);
      break;

    case 'NewExpression':
      parseNewExpression(state, expression);
      break;

    case 'ReturnStatement':
      parseReturnStatement(state, expression);
      break;

    case 'SourceUnit':
      parseSourceUnit(state, expression);
      break;

    case 'TryStatement':
      parseTryStatement(state, expression);
      break;

    case 'VariableDeclarationStatement':
      parseVariableDeclarationStatement(state, expression);
      break;

    case 'WhileStatement':
      parseWhileStatement(state, expression);
      break;

    case 'InlineAssemblyStatement':
      parseInlineAssemblyStatement(state, expression);
      break;

    case 'UnaryOperation':
      parseUnaryOperation(state, expression);
      break;

    case 'ContinueStatement':
      parseContinueStatement(state, expression);
      break;

    case 'BreakStatement':
      parseBreakStatement(state, expression);
      break;
  }
}

function parseBlock(state, expression) {
  for (var x = 0; x < expression.statements.length; x++) {
    parseExpression(state, expression.statements[x]);
  }
}

function parseBinaryOperation(state, expression) {
  registerStatement(state, expression); // TODO: Ternary expressions are currently not supported.

  if (expression.right.type === 'Conditional') {
    // TODO: Location is incorrectly typed in solidty-parser.
    var location = expression.loc;
    console.warn("Instrumentation for ternary statements is currently not supported: ".concat(state.contract, ":").concat(location.start.line));
  }
}

function parseFunctionCall(state, expression) {
  if (expression.expression.type !== 'FunctionCall') {
    registerStatement(state, expression);
    parseExpression(state, expression.expression);
  } else {
    parseExpression(state, expression.expression);
  }
}

function parseContractDefinition(state, expression) {
  // Interfaces don't have any relevant instrumentation.
  if (expression.kind === 'interface') {
    return;
  } // We need to define a method to pass coverage hashes into at top of each target.
  // This lets us get a fresh stack for the hash and avoid stack-too-deep errors.


  var start = 0; // It's possible a base contract will have constructor string arg
  // which contains an open curly brace. Skip ahead pass the bases...

  if (expression.baseContracts && expression.baseContracts.length) {
    var _iterator = _createForOfIteratorHelper(expression.baseContracts),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var base = _step.value;

        if (base.range && base.range[1] > start) {
          start = base.range[1];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else if (expression.range) {
    start = expression.range[0];
  }

  var end = state.source.slice(start).indexOf('{') + 1;
  var loc = start + end;
  state.contract = expression.name;
  createInjection(state, loc, {
    type: 'HashMethod'
  });

  if (expression.subNodes) {
    expression.subNodes.forEach(function (construct) {
      parseExpression(state, construct);
    });
  }
}

function parseFunctionDefinition(state, expression) {
  if (expression.modifiers) {
    expression.modifiers.forEach(function (modifier) {
      return parseExpression(state, modifier);
    });
  }

  registerFunction(state, expression);

  if (expression.body) {
    parseExpression(state, expression.body);
  }
}

function parseIfStatement(state, expression) {
  var before = state.branch;
  state.branch = registerBranch(state, expression);
  parseExpression(state, expression.trueBody);
  registerBranchLocation(state, expression.trueBody);
  ensureBlock(state, expression.trueBody);

  if (expression.falseBody) {
    if (expression.falseBody.type === 'IfStatement') {
      // If `falseBody` in an `IfStatement` and also has `falseBody` itself, it's a nested branch.
      if (expression.falseBody.falseBody) {
        parseExpression(state, expression.falseBody);
      } else {
        parseExpression(state, expression.falseBody.trueBody);
      }
    } else {
      // Otherwise it's just an `else` statement.
      parseExpression(state, expression.falseBody);
    }

    registerBranchLocation(state, expression.falseBody);
    ensureBlock(state, expression.falseBody);
  }

  state.branch = before;
}

function parseModifierDefinition(state, expression) {
  registerFunction(state, expression);
  parseExpression(state, expression.body);
}

function parseSourceUnit(state, expression) {
  expression.children.forEach(function (construct) {
    parseExpression(state, construct);
  });
} // TODO: This doesn't have a proper type.


function parseTryStatement(state, expression) {
  parseExpression(state, expression.body);

  for (var x = 0; x < expression.catchClauses.length; x++) {
    parseExpression(state, expression.catchClauses[x].body);
  }
}

function parseWhileStatement(state, expression) {
  // TODO: This is incorrectly typed in solidity-parser.
  var typed = expression;
  parseExpression(state, typed.body);
  ensureBlock(state, typed.body);
} // TODO: This doesn't have a proper type.


function parseNewExpression(state, expression) {
  parseExpression(state, expression.typeName);
}

function parseReturnStatement(state, expression) {
  registerStatement(state, expression);
}

function parseVariableDeclarationStatement(state, expression) {
  registerStatement(state, expression);
}

function parseUnaryOperation(state, expression) {
  registerStatement(state, expression);
}

function parseInlineAssemblyStatement(state, expression) {
  registerStatement(state, expression);
}

function parseContinueStatement(state, expression) {
  registerStatement(state, expression);
}

function parseBreakStatement(state, expression) {
  registerStatement(state, expression);
}

function parseEmitStatement(state, expression) {
  registerStatement(state, expression);
}

function parseExpressionStatement(state, expression) {
  parseExpression(state, expression.expression);
}

function parseForStatement(state, expression) {
  parseExpression(state, expression.body);
  ensureBlock(state, expression.body);
}

function ensureBlock(state, expression) {
  if (expression.type !== 'Block') {
    createInjection(state, expression.range[0], {
      delimiter: BlockDelimiter.OPEN,
      type: 'BlockDelimiter'
    });
    createInjection(state, expression.range[1] + 1, {
      delimiter: BlockDelimiter.CLOSE,
      type: 'BlockDelimiter'
    });
  }
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
function instrumentSource(source, file) {
  var parsed = parse(source);
  return inject(parsed, file);
}
function instrumentSources(sources) {
  var instrumented = Object.entries(sources).reduce(function (carry, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        path = _ref2[0],
        source = _ref2[1];

    var instrumented = instrumentSource(source, path);
    return _objectSpread(_objectSpread({}, carry), {}, _defineProperty({}, path, instrumented));
  }, {});
  var metadata = Object.entries(instrumented).reduce(function (carry, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        path = _ref4[0],
        instrumented = _ref4[1];

    // Ignore metadata for all files with no instrumentation (e.g. interfaces).
    if (Object.keys(instrumented.instrumentations).length === 0) {
      return carry;
    }

    carry.instrumentations = _objectSpread(_objectSpread({}, carry.instrumentations), instrumented.instrumentations);
    carry.targets[path] = {
      branches: instrumented.branches,
      functions: instrumented.functions,
      path: path,
      statements: instrumented.statements
    };
    return carry;
  }, {
    instrumentations: {},
    targets: {}
  });
  return {
    instrumented: instrumented,
    metadata: metadata
  };
}

function createCoverageCollector(metadata, recording) {
  var _metadata$instrumenta;

  var instrumentation = (_metadata$instrumenta = metadata.instrumentations) !== null && _metadata$instrumenta !== void 0 ? _metadata$instrumenta : {};
  return function (info) {
    if (info.opcode.name === 'PUSH1' && info.stack.length > 0) {
      var hash = toHex(info.stack[info.stack.length - 1].toString(16));

      if (instrumentation[hash]) {
        var _recording$hash;

        recording[hash] = ((_recording$hash = recording[hash]) !== null && _recording$hash !== void 0 ? _recording$hash : 0) + 1;
      }
    }
  };
}
function mergeCoverageReports(recording, metadata) {
  // Set up the coverage map using for all contracts.
  var coverage = istanbulLibCoverage.createCoverageMap();
  Object.keys(metadata.targets).forEach(function (contract) {
    var file = istanbulLibCoverage.createFileCoverage({
      b: {},
      branchMap: metadata.targets[contract].branches,
      f: {},
      fnMap: metadata.targets[contract].functions,
      path: contract,
      s: {},
      statementMap: metadata.targets[contract].statements
    });
    Object.keys(metadata.targets[contract].functions).map(function (key) {
      file.f[key] = 0;
    });
    Object.keys(metadata.targets[contract].statements).map(function (key) {
      file.s[key] = 0;
    });
    Object.entries(metadata.targets[contract].branches).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          branch = _ref2[1];

      file.b[key] = branch.locations.map(function () {
        return 0;
      });
    });
    coverage.addFileCoverage(file);
  }); // Collect all the coverage data by looping through the recorded hits.

  Object.entries(recording).forEach(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        hash = _ref4[0],
        hits = _ref4[1];

    var instrumentation = metadata.instrumentations[hash];
    var file = coverage.fileCoverageFor(instrumentation.target);

    switch (instrumentation.type) {
      case 'function':
        {
          file.f[instrumentation.id] += hits;
          return;
        }

      case 'statement':
        {
          file.s[instrumentation.id] += hits;
          return;
        }

      case 'branch':
        {
          var _file$b$instrumentati;

          var before = (_file$b$instrumentati = file.b[instrumentation.id][instrumentation.branch]) !== null && _file$b$instrumentati !== void 0 ? _file$b$instrumentati : 0;
          file.b[instrumentation.id][instrumentation.branch] = before + hits;
          return;
        }
    }
  });
  return coverage;
}

function toHex(value) {
  // If negative, prepend the negative sign to the normalized positive value.
  if (value[0] === '-') {
    // Strip off the negative sign.
    value = value.substring(1); // Call toHex on the positive component.

    value = toHex(value); // Do not allow "-0x00".

    if (value === '0x00') {
      return value;
    } // Negate the value.


    return '-' + value;
  } // Add a "0x" prefix if missing.


  if (value.substring(0, 2) !== '0x') {
    value = '0x' + value;
  } // Normalize zero.


  if (value === '0x') {
    return '0x00';
  } // Make the string even length.


  if (value.length % 2) {
    value = '0x0' + value.substring(2);
  } // Trim to smallest even-length string.


  while (value.length > 4 && value.substring(0, 4) === '0x00') {
    value = '0x' + value.substring(4);
  }

  return value;
}

exports.createCoverageCollector = createCoverageCollector;
exports.instrumentSource = instrumentSource;
exports.instrumentSources = instrumentSources;
exports.mergeCoverageReports = mergeCoverageReports;
